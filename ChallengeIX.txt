trigger CheckOppTrigger on Account (before insert, after insert, before delete) {
    
    Switch on Trigger.OperationType {
        when BEFORE_INSERT {
            Map<Id, Account> accList = new Map<Id, Account>(
                [SELECT Id, BillingAddress FROM Account Where Id IN :Trigger.New]);
            for(account a: Trigger.New){
                //if(a.Name == 'bb'){//(a.BillingAddress.getState() == 'CA'){
                if(a.BillingState == 'CA'){
                    a.addError('Custom Trigger: Cannot add Account for Californians.');
                }
            }
        } 
        when BEFORE_UPDATE {
            
        }
        when BEFORE_DELETE {
            List<Opportunity> oppList = new List<Opportunity>();
    
    		Map<Id, Account> acctsWithOpps = new Map<Id, Account>(
    		[SELECT Id, (SELECT StageName FROM Opportunities WHERE (StageName != 'Closed Won' OR StageName != 'Closed Lost')) FROM Account WHERE Id IN :Trigger.Old]
   			 );
    
    		for(Account a : Trigger.Old) {
        		System.debug('acctsWithOpps.get(a.Id).Opportunities.size()=' + acctsWithOpps.get(a.Id).Opportunities.size());
        
        		if(acctsWithOpps.get(a.Id).Opportunities.size() > 0){
            		a.addError('Custom Trigger: Cannot Delete because there are opportunities that are not Close Won/Lost.');
        		}
    		}
        }
        when AFTER_INSERT {
            List<Contact> cList = new List<Contact>();
    
    		Map<Id, Account> accList = new Map<Id, Account>(
    			[SELECT Id, (SELECT Id FROM Contacts) FROM Account WHERE Id IN :Trigger.New]
    		);
            for (account a: Trigger.New){
                if ( accList.get(a.Id).Contacts.size() == 0){
                    cList.add(new Contact(LastName = 'cntact',
                                          AccountId = a.Id));
                }
            }
            if(cList.size() > 0)
                insert cList;
        }
        when AFTER_UPDATE {
            
        }
        when AFTER_DELETE {
            
        }
        when AFTER_UNDELETE {
            
        } when else {
            
        }
        
    }
}